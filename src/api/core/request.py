from dataclasses import dataclass, asdict, field
from typing import Any, NotRequired, TypedDict, Required, TypeVar, Union
from uuid import UUID

from pydantic import BaseModel

from src import util

from .symbols import Attribute, Identifier, Serializable, Timestamp

RequestModel = type[BaseModel]


class SerializableObj(Serializable):
    @property
    def json(self) -> dict: ...


class _Payload(TypedDict, total=False):
    identifier: Required[Identifier]
    attribute: NotRequired[Attribute]
    timestamp: NotRequired[Timestamp]


Payload = TypeVar("Payload", bound=Union[_Payload, dict[str, Any]])


@dataclass
class Request(SerializableObj):
    """Represents a single unit of work to be processed by the API.

    Args:
        provider: Corresponds to folder name in `ext`
        router: Identifies the specific function to call within the provider
        payload: Dictionary of keyword arguments for the router function (identifier, attribute, timestamp)
        _id: The id of the request. Generated by `util.ident.uuid` if not provided
        _submitted_at: The timestamp of the request. Generated by `util.dt.timestamp` if not provided
        _metadata: Optional metadata to include with the request. Empty dict by default
    """
    provider: str = field()
    router: str = field()
    payload: Payload = field(default_factory=dict)
    _id: UUID = field(default_factory=util.ident.uuid)
    _submitted_at: util.dt.time = field(default_factory=util.dt.timestamp)
    _metadata: dict = field(default_factory=dict)

    @property
    def id(self) -> UUID:
        return self._id

    @property
    def submitted_at(self) -> util.dt.time:
        return self._submitted_at

    @property
    def json(self) -> dict:
        return asdict(self)

    @property
    def metadata(self) -> dict:
        return dict(self._metadata)
